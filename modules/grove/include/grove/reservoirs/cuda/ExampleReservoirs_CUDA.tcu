/**
 * grove: ExampleReservoirs_CUDA.tcu
 * Copyright (c) Torr Vision Group, University of Oxford, 2017. All rights reserved.
 */

#include "ExampleReservoirs_CUDA.h"

#include <itmx/base/MemoryBlockFactory.h>

#include "../shared/ExampleReservoirs_Shared.h"

namespace grove {

//#################### CUDA KERNELS ####################

template <typename ExampleType>
__global__ void ck_add_examples(const ExampleType *examples, const Vector2i imgSize, const char *reservoirIndices, uint32_t reservoirIndicesCount, uint32_t reservoirIndicesStep,
                                CUDARNG *randomStates, ExampleType *reservoirs, int *reservoirSize, int *reservoirAddCalls, uint32_t reservoirCapacity)
{
  const int x = threadIdx.x + blockIdx.x * blockDim.x;
  const int y = threadIdx.y + blockIdx.y * blockDim.y;

  if (x >= imgSize.x || y >= imgSize.y) return;

  const int linearIdx = y * imgSize.x + x;
  const int linearIndicesIdx = (y * imgSize.x + x) * reservoirIndicesStep;
  const int* indices = reinterpret_cast<const int*>(reservoirIndices + linearIndicesIdx);

  example_reservoirs_add_example(examples[linearIdx], indices, reservoirIndicesCount, randomStates[linearIdx], reservoirs, reservoirSize, reservoirAddCalls, reservoirCapacity);
}

// Declare a non-templated kernel used to initialise the RNG states. See the associated .cu file.
__global__ void ck_init_random_states(CUDARNG *randomStates, uint32_t nbStates, uint32_t seed);

//#################### CONSTRUCTORS ####################

template <typename ExampleType>
ExampleReservoirs_CUDA<ExampleType>::ExampleReservoirs_CUDA(uint32_t reservoirCapacity, uint32_t reservoirCount, uint32_t rngSeed)
: ExampleReservoirs<ExampleType>(reservoirCapacity, reservoirCount, rngSeed)
{
  itmx::MemoryBlockFactory& mbf = itmx::MemoryBlockFactory::instance();

  // Initialise the random number generators.
  m_randomStates = mbf.make_block<CUDARNG>();
  init_random();
}

//#################### PUBLIC VIRTUAL MEMBER FUNCTIONS ####################

template <typename ExampleType>
void ExampleReservoirs_CUDA<ExampleType>::clear()
{
  ExampleReservoirs<ExampleType>::clear();
  init_random();
}

//#################### PROTECTED VIRTUAL MEMBER FUNCTIONS ####################

template <typename ExampleType>
void ExampleReservoirs_CUDA<ExampleType>::add_examples(const ExampleImage_CPtr& examples, const char *reservoirIndicesCPU,
                                                       const char *reservoirIndicesCUDA, uint32_t reservoirIndicesCount,
                                                       uint32_t reservoirIndicesStep)
{
  const Vector2i imgSize = examples->noDims;
  const size_t nbExamples = imgSize.width * imgSize.height;

  // Check that we have enough random states and, if not, reallocate them.
  if (nbExamples > m_randomStates->dataSize)
  {
    m_randomStates->Resize(nbExamples);
    init_random();
  }

  const ExampleType *exampleData = examples->GetData(MEMORYDEVICE_CUDA);

  CUDARNG *randomStates = m_randomStates->GetData(MEMORYDEVICE_CUDA);
  int *reservoirAddCalls = this->m_reservoirAddCalls->GetData(MEMORYDEVICE_CUDA);
  ExampleType *reservoirData = this->m_reservoirs->GetData(MEMORYDEVICE_CUDA);
  int *reservoirSizes = this->m_reservoirSizes->GetData(MEMORYDEVICE_CUDA);

  dim3 blockSize(32, 32);
  dim3 gridSize((imgSize.width + blockSize.x - 1) / blockSize.x,
      (imgSize.height + blockSize.y - 1) / blockSize.y);
  ck_add_examples<<<gridSize, blockSize>>>(exampleData, imgSize, reservoirIndicesCUDA,
      reservoirIndicesCount, reservoirIndicesStep, randomStates,
      reservoirData, reservoirSizes, reservoirAddCalls, this->m_reservoirCapacity);
  ORcudaKernelCheck;
}

//#################### PRIVATE MEMBER FUNCTIONS ####################

template <typename ExampleType>
void ExampleReservoirs_CUDA<ExampleType>::init_random()
{
  const int nbStates = static_cast<int>(m_randomStates->dataSize);

  if (nbStates == 0) return;

  CUDARNG *randomStates = m_randomStates->GetData(MEMORYDEVICE_CUDA);

  // Initialize random states
  dim3 blockSize(256);
  dim3 gridSize((nbStates + blockSize.x - 1) / blockSize.x);
  ck_init_random_states<<<gridSize, blockSize>>>(randomStates, nbStates, this->m_rngSeed);
  ORcudaKernelCheck;
}

}

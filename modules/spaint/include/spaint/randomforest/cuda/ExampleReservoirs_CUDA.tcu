/**
 * spaint: ExampleReservoirs_CUDA.tcu
 * Copyright (c) Torr Vision Group, University of Oxford, 2016. All rights reserved.
 */

#ifndef H_SPAINT_EXAMPLERESERVOIRSCUDATCU
#define H_SPAINT_EXAMPLERESERVOIRSCUDATCU

#include "randomforest/cuda/ExampleReservoirs_CUDA.h"
#include "randomforest/shared/ExampleReservoirs_Shared.h"
#include "util/MemoryBlockFactory.h"

using namespace tvgutil;

namespace spaint
{
template<typename ExampleType, typename FeatureType, typename LeafType>
__global__ void ck_add_examples(const FeatureType *features,
    const LeafType *leafIndices, Vector2i imgSize, CUDARNG *randomStates,
    ExampleType *reservoirs, int *reservoirSize, int *reservoirAddCalls,
    uint32_t reservoirCapacity)
{
  const int x = threadIdx.x + blockIdx.x * blockDim.x;
  const int y = threadIdx.y + blockIdx.y * blockDim.y;

  if (x >= imgSize.x || y >= imgSize.y)
    return;

  const int linearIdx = y * imgSize.x + x;

  example_reservoirs_add_example(features[linearIdx], leafIndices[linearIdx],
      randomStates[linearIdx], reservoirs, reservoirSize, reservoirAddCalls,
      reservoirCapacity);
}

template<typename ExampleType, typename FeatureType, typename LeafType>
ExampleReservoirs_CUDA<ExampleType, FeatureType, LeafType>::ExampleReservoirs_CUDA(
    size_t capacity, size_t nbLeaves, uint32_t rngSeed) :
    ExampleReservoirs<ExampleType, FeatureType, LeafType>(capacity, nbLeaves,
        rngSeed)
{
  MemoryBlockFactory &mbf = MemoryBlockFactory::instance();
  m_randomStates = mbf.make_block<CUDARNG>();

  // Update device for the other variables (not m_data since its content are meaningless now)
  m_reservoirsAddCalls->UpdateDeviceFromHost();
  m_reservoirsSize->UpdateDeviceFromHost();

  init_random();
}

template<typename ExampleType, typename FeatureType, typename LeafType>
void ExampleReservoirs_CUDA<ExampleType, FeatureType, LeafType>::add_examples(
    const FeatureImage_CPtr &features, const LeafImage_CPtr &leafIndices)
{
  const Vector2i imgSize = features->noDims;
  const int nbExamples = imgSize.width * imgSize.height;

  // Check that we have enough random states and if not reallocate them
  if (nbExamples > m_randomStates->dataSize)
  {
    m_randomStates->ChangeDims(nbExamples);
    init_random();
  }

  const FeatureType *featureData = features->GetData(MEMORYDEVICE_CUDA);
  const LeafType *leafIndicesData = leafIndices->GetData(MEMORYDEVICE_CUDA);

  CUDARNG *randomStates = m_randomStates->GetData(MEMORYDEVICE_CUDA);
  ExampleType *reservoirData = m_data->GetData(MEMORYDEVICE_CUDA);
  int *reservoirSize = m_reservoirsSize->GetData(MEMORYDEVICE_CUDA);
  int *reservoirAddCalls = m_reservoirsAddCalls->GetData(MEMORYDEVICE_CUDA);

  dim3 blockSize(32, 32);
  dim3 gridSize((imgSize.width + blockSize.x - 1) / blockSize.x,
      (imgSize.height + blockSize.y - 1) / blockSize.y);
  ck_add_examples<<<gridSize, blockSize>>>(featureData, leafIndicesData, imgSize, randomStates,
      reservoirData, reservoirSize, reservoirAddCalls, m_reservoirCapacity);
  ORcudaKernelCheck;
}

template<typename ExampleType, typename FeatureType, typename LeafType>
void ExampleReservoirs_CUDA<ExampleType, FeatureType, LeafType>::clear()
{
  m_reservoirsSize->Clear();
  m_reservoirsAddCalls->Clear();
  init_random();
}

__global__ void ck_init_random_states(CUDARNG *randomStates, uint32_t nbStates,
    uint32_t seed);

template<typename ExampleType, typename FeatureType, typename LeafType>
void ExampleReservoirs_CUDA<ExampleType, FeatureType, LeafType>::init_random()
{
  const size_t nbStates = m_randomStates->dataSize;

  if (nbStates == 0)
    return;

  CUDARNG *randomStates = m_randomStates->GetData(MEMORYDEVICE_CUDA);

  // Initialize random states
  dim3 blockSize(256);
  dim3 gridSize((nbStates + blockSize.x - 1) / blockSize.x);
  ck_init_random_states<<<gridSize, blockSize>>>(randomStates, nbStates, m_rngSeed);
  ORcudaKernelCheck;
}

}

#endif
